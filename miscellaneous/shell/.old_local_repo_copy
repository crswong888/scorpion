#!/bin/bash

# NOTE: if this script overloads buff/cache memory, it can be cleared with the following command:
# `sudo sh -c "echo 1 > /proc/sys/vm/drop_caches"`

function printusage {
    echo "Usage:    .local_repo_copy <destination> <options>"
    echo
    echo "    A script for copying both tracked and untracked files in a local Git repository to"
    echo "    a specified destination. This is useful for uploading backups to a cloud storage."
    echo "    This script can be called from within a subdirectory of a repository to copy only its"
    echo "    contents. Submodule directories are copied but not traversed, leaving the copy empty."
    echo ""
    echo "    <destination> The name of the folder to store the copy in."
    echo ""
    echo "    <options> Non-positional arguments supplied after <destination>:"
    echo ""
    echo "              --untracked"
    echo "                  Include untracked files not matching a .gitignore pattern in the copy."
    echo ""
    echo "              -f, --force"
    echo "                  Overwrite existing files in the directory specified by <destination>."
    echo ""
}

if [[ $1 == "-h" || $1 == "--help" || $# == 0 || $# > 3 ]]; then
    printusage
    exit 1
fi

# function for copying a complete filepath to a specified destination
function copyfile {
  dstpath="$(dirname $2)"
  if [ ! -d $dstpath ]; then
    mkdir -p $dstpath
  fi

  # copy file or symbolic link only if its new - return a nonzero exit status if nothing is copied
  verbose=$(cp -TPpuv $1 $2 2> /tmp/.copyfile_stderr)
  if [ $? -ne 0 ]; then
    echo -e "\nError: ("$(cat /tmp/.copyfile_stderr)")" && rm /tmp/.copyfile_stderr
    exit 1
  elif [[ $verbose ]]; then
    echo $verbose
  else
    return 1
  fi
}

# converts bytes to a smaller nonbinary (decimal) prefixed value kilo (k), mega (M), and giga (G)
function convertBytes {
  digits=${#1}

  if [ $digits -lt 4 ]; then
    echo "$1 bytes"
  elif [ $digits -lt 7 ]; then
    printf "%0.1f kB" $(echo "scale = 16; $1 / 1000" | bc)
  elif [ $digits -lt 10 ]; then
    printf "%0.1f MB" $(echo "scale = 16; $1 / 1000 / 1000" | bc)
  else
    printf "%0.1f GB" $(echo "scale = 16; $1 / 1000 / 1000 / 1000" | bc)
  fi
}

# make sure this script is ran from inside a git repo
if ! $(git rev-parse --is-inside-work-tree 2> /dev/null); then
  echo "Error: This script must be ran from within the working tree of a valid Git repository."
  exit 1
fi

# create destination folder, but error if it already exists and not forcing an overwrite
dstname="${1%/}/"
if [ -d $dstname ] && ! [[ $2 == "-f" || $2 == "--force" || $3 == "-f" || $3 == "--force" ]]; then
  echo "Error: Directory '$dstname' already exists. Use -f or --force to replace existing files."
  exit 1
fi

# get a list of files to copy
gitfiles=$(git ls-files)
if [[ $2 == "--untracked" || $3 == "--untracked" ]]; then
  gitfiles+=" "$(git ls-files --exclude-standard --others)
fi

# get a list of submodule names so we know to skip copying of all their contents
gitmodules=$(git rev-parse --show-cdup)".gitmodules"
submodules=$(git config --file $gitmodules --get-regexp path | awk '{print $2}')

# copy/merge files while computing approximate logical size (not disk usage) of all new data written
cwd=$(git rev-parse --show-prefix)
size=$((0))
for file in $gitfiles
do
  if [[ $submodules =~ (^|[[:space:]])$file($|[[:space:]]) ]]; then
    mkdir -p $dstname$cwd$file
  elif copyfile $file $dstname$cwd$file; then
    size=$(($size + $(du -b $file | tail -n1 | awk '{print $1}')))
  fi
done

# indicate completion with message containing total logical size of files copied
echo -e "\nFinished copying local state of files totaling $(convertBytes $size) to '$dstname$cwd'"
