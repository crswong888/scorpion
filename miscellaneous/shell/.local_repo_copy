#!/bin/bash

# NOTE: if this script overloads buff/cache memory, it can be cleared with the following command:
# `sudo sh -c "echo 1 > /proc/sys/vm/drop_caches"`

function printusage {
    echo "Usage:    .local_repo_copy <destination> <options>"
    echo
    echo "    A script for copying both tracked and untracked files in a local Git repository to"
    echo "    a specified destination. This is useful for uploading backups to a cloud storage."
    echo "    This script can be called from within a subdirectory of a repository to copy only its"
    echo "    contents. Submodule directories are copied but not traversed, leaving the copy empty."
    echo ""
    echo "    <destination> The name of the folder to store the copy in."
    echo ""
    echo "    <options> Non-positional arguments supplied after <destination>:"
    echo ""
    echo "              --untracked"
    echo "                  Include untracked files not matching a .gitignore pattern in the copy."
    echo ""
    echo "              -f, --force"
    echo "                  Overwrite existing files in the directory specified by <destination>."
    echo ""
}

if [[ $1 == "-h" || $1 == "--help" || $# == 0 || $# > 3 ]]; then
    printusage
    exit 1
fi

# function for copying a complete filepath to a specified destination
function copyfile {
  dstpath="$(dirname $2)"
  if [ ! -d $dstpath ]; then
    mkdir -p $dstpath
  fi

  # copy with attributes a file or symbolic link and be verbose about it, but only if it's new
  cp -TPpuv $1 $2
}

# make sure this script is ran from inside a git repo
if ! $(git rev-parse --is-inside-work-tree 2> /dev/null); then
  echo "Error: This script must be ran from within the working tree of a valid Git repository."
  exit 1
fi

# create destination folder, but error if it already exists and not forcing an overwrite
dstname="${1%/}/"
if [ -d $dstname ] && ! [[ $2 == "-f" || $2 == "--force" || $3 == "-f" || $3 == "--force" ]]; then
  echo "Error: Directory '$dstname' already exists. Use -f or --force to replace existing files."
  exit 1
fi

# get a list of files to copy
gitfiles=$(git ls-files)
if [[ $2 == "--untracked" || $3 == "--untracked" ]]; then
  gitfiles+=" "$(git ls-files --exclude-standard --others)
fi

# get a list of submodule names so we know to skip copying of all their contents
gitmodules=$(git rev-parse --show-cdup)".gitmodules"
submodules=$(git config --file $gitmodules --get-regexp path | awk '{print $2}')

# copy .git folder so result is a true copy of local repository, and not just a clone
if [ -d .git ] & [ $PWD == $(git rev-parse --show-toplevel) ]; then
  echo -n "Copying directory '.git' to preserve the local state of the repository... "
  cp -fru .git $dstname
  echo "Done."
fi

# loop through local files list and copy/merge them or create empty directories for submodules
echo "Copying current state of local files. This may take a moment."

dst=$dstname$(git rev-parse --show-prefix)
for file in $gitfiles
do
  if [[ $submodules =~ (^|[[:space:]])$file($|[[:space:]]) ]]; then
    mkdir -p $dst$file
  else
    copyfile $file $dst$file
  fi
done

echo -e "\nFinished copying all files on the working tree to '$dst'"
